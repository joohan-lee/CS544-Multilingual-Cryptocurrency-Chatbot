# -*- coding: utf-8 -*-
"""Multilingual_Chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YE273ObFFTPlao8JT6ycryG0ABxCdQJE

# Chatbot


"""  # Load Quora QA data"""

import requests
from bs4 import BeautifulSoup
from googletrans import Translator
import time
import joblib
from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer
import torch
import random
import csv
import numpy as np
import pandas as pd


def load_qa():
    # Load QA dataset
    with open("./data/quora_all_qa.csv", 'r') as file:
        csvreader = csv.reader(file)
        question_list = []
        answer_list = []
        for row in csvreader:
            question_list.append(row[0])
            answer_list.append(row[1])

    crypto_df = pd.DataFrame()
    crypto_df['question'] = question_list
    crypto_df['answer'] = answer_list

    return crypto_df


def get_price(coin):
    # function to get the price of a cryptocurrency

    # make up the URL
    url = "https://www.google.com/search?q=" + coin + "+price"

    # make the request
    content = requests.get(url)

    # parse the response
    soup = BeautifulSoup(content.text, 'html.parser')

    # find the price
    text = soup.find("div", attrs={'class': 'BNeawe iBp4i AP7Wnd'}).text

    # return the price
    return text


def translate_question(text, lang):
    # translator = Translator()
    translator = Translator(service_urls=[
        'translate.google.com',
    ])

    # If text is not english, translate it.
    return translator.translate(text=text, src=lang, dest='en').text if lang != 'en' else text


def translate_answer(text):
    # translator = Translator()
    translator = Translator(service_urls=[
        'translate.google.com',
    ])

    lang = translator.detect(text).lang

    # If text is not english, translate it.
    return translator.translate(text=text, dest='en').text if lang != 'en' else text


def return_answer(question, answer_list):

    ####### Translate question #######
    # detect the language
    translator = Translator(service_urls=[
        'translate.google.com',
    ])
    lang = translator.detect(question).lang

    # If text is not english, translate it.
    if lang != 'en':
        question = translator.translate(
            text=question, src=lang, dest='en').text

    ##########################

    ###### Cryptocurrency price ########
    if 'price' in question.lower():
        # check if user is asking the price of crpytocurrency in our supported list.
        crypto_set = set()
        with open('/data/top50_crypto.txt') as f_cryto:
            for line in f_cryto.readlines():
                crypto_set.add(line.strip())

        words = question.split()
        coin = ""
        for c in crypto_set:
            _c = c.replace(' ', '').lower()
            if _c in question.replace(' ', '').lower() and len(coin) < len(_c):
                coin = c

        if coin == "":
            return "Sorry, we don't support the given coin."

        return 'The current price of ' + coin + ' is ' + get_price(coin) + "."
    ######################################

    ###### Get answer from the question that has highest cosine similarity using SBERT 'distilbert-base-nli-max-tokens' model ######
    question_embedding = bert_model.encode([question])

    scores = cosine_similarity(question_embedding, sentence_embeddings)
    index = np.argmax(cosine_similarity(
        question_embedding, sentence_embeddings))

    # If the cosine similarity is higher or equal to 0.85, return answer
    if scores[0][index] >= 0.85:
        answer = answer_list[index]
    else:
        answer = 'Sorry, I do not understand the question.'

    # If the language of question was not english, translate answer into the given language.
    if lang != 'en':
        answer = translator.translate(text=answer, src='en', dest=lang).text

    return answer


"""### Chatbot"""

if __name__ == "__main__":
    # Load the qa data
    crypto_df = load_qa()

    # Train the model(Embedding question sentences)
    bert_model = SentenceTransformer(
        'sentence-transformers/distilbert-base-nli-max-tokens')
    sentence_embeddings = bert_model.encode(crypto_df['question'])

    # Check an example of cosine-similarity between similar questions
    # question1 = bert_model.encode(
    #     ['how do people send crypto from a trust wallet to binance'])
    # question2 = bert_model.encode(
    #     ['how to send cyrto to binance from trust wallet'])
    # print(cosine_similarity(question2, question1))

    while True:
        # Users' ask
        user_ask = input('Type your question: ')

        # exit_conditions
        if 'bye' or 'quit' or 'exit' in user_ask.lower():
            break

        # get answer
        answer_sentence = return_answer(user_ask, crypto_df['answer'])

        print(answer_sentence)
        print('---------------')
